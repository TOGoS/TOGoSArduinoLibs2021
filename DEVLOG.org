#+TITLE: TOGoS Arduino Apps Development Log

** Library locations

Core libraries,
installed libraries,
and 'board' libraries
are all in totally different places!

- Boards :: ~C:\Users\TOGoS\AppData\Local\Arduino15\packages~
  - e.g. the esp8266 WiFi library (part of it, anyway) is at ~c:/Users/TOGoS/AppData/Local/Arduino15/packages/esp8266/hardware/esp8266/3.0.2/libraries/ESP8266WiFi/src/ESP8266WiFiSTA.h~
- Core Libraries :: ~C:\Program Files (x86)\Arduino\libraries~
- Installed Libraries :: ~C:\Users\TOGoS\Documents\Arduino\libraries~
  - e.g. the Nick O'Leary PubSubClient that I like is in ~"C:\Users\TOGoS\Documents\Arduino\libraries\PubSubClient"~

** 2025-06-10 - HELODemo - IPv6 on ESP8266 research

Looking at the ESP8266WiFi > IPv6 example.

It seems I need to select Tools > 'lwIP variant' = 'v2 IPv6 Lower Memory' or somesuch in order to get it to IPv6 at all.

Then I get output like:

#+begin_example
------------------------------
SDK:2.2.2-dev(38a443e)/Core:3.0.2=30002000/lwIP:IPv6+STABLE-2_1_2_RELEASE/glue:1.2-48-g7421258/BearSSL:6105635
dns0: 192.168.9.1
dns1: 2600:1702:7ab0:ac10::1
Try me at these addresses:
(with 'telnet <addr> or 'nc -u <addr> 23')
IF='st' IPv6=0 local=0 hostname='ESP-34447B' addr= 192.168.9.161 / mask:255.255.255.0 / gw:192.168.9.1
IF='st' IPv6=1 local=1 hostname='ESP-34447B' addr= fe80::5ecf:7fff:fe34:447b
IF='st' IPv6=1 local=0 hostname='ESP-34447B' addr= 2600:1702:7ab0:ac10:5ecf:7fff:fe34:447b
resolving www.google.com: 172.253.124.106
resolving ipv6.google.com: 2607:f8b0:4002:c00::71
resolving www.google.com: 172.253.124.106
resolving www.yahoo.com: 2001:4998:60:807::1
------------------------------
#+end_example

It still connects to the IPv4 network.
I kind of don't want to do that.
The whole point was to avoid cluttering my local network's limited space!

But I maybe could use [[https://docs.arduino.cc/libraries/wifi/#%60WiFi.config()%60][WiFi.config(ip, dns, gateway, subnet)]] (dns, gateway, subnet are each optional)
to manually configure some IPv4 address not on my network.

10.9.7.254, let's say, could be the dummy IPv4 address.

*** Other thoughts

A way to get more frequent updates without spamming the network:
- Broadcast a few updates right away, then seldomly (once per minute or something)
- A 'client' can send a packet indicating its interest, maybe every few minutes,
  and the device will then send packets to that device more often,
  and maybe in more detail.
  - Could be a ~#HELO/SUBSCRIBE /topic~ kind of thing!

** 2025-06-12 - HELODemo - Next steps

*** DONE Decide on a standard HELO UDP port

16378 is not mentioned on https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers, so that.

Published update to https://www.nuke24.net/docs/2025/HELO.html.

*** TODO Broadcast a UDP packet

Some findings:

Broadcasting to ~ff02::1~, either from the device or using ~nc~, works,
and I can receive the packet using ~nc~ or using ~udplisten.ts~ on another Linux machine.

On Windows I can't seem to receive the broadcast packets, even after changing some firewall settings.
But I can receive the packets sent directly to my link-local IPv6 address
(this is all using ~udplisten.ts~).

Note: ~nc~ seems to require the device to be specified (e.g. ~ff02::1%enp4s0~) when sending packets,
but not when listening.

Note: ~nc~ has a ~-b~ option to 'allow broadcast', but I think that's only relevant to IPv4.
IPv6 has special addresses for broadcasting so doesn't need that bit, and ~nc~ will say
"Protocol not available" if you tell it to ~-b~ when sending a UDP packet over IPv6.

Note: ~nc~ picks a random port to send from unless you indicate a different source port with ~-p~.

Note: ~nc~ seems to ignore end-of-input-stream, and you have to C-c to kill it.
Alternatively you can ~-q 1~ to have it quit after one second, but this seems
to be one second after sending something out...or after EOF is reached?
~-q 0~ works when I typre stuff in but not when ~echo~ing input to it.

**** Listening with nc

#+begin_src bash
nc -u -l :: 16378
#+end_src

#+begin_example
#HELO

What's up lamo
#+end_example

Nc seems to only spit out the first packet received.

**** Listening with UDPListen.ts

#+begin_src bash
deno run --allow-net --unstable-net UDPListen.ts [::]:16378
#+end_src

#+begin_example
Received 21 bytes from {"hostname":"fe80::5ecf:7fff:fe34:447b","port":16378,"transport":"udp"}: 2348454c4f0a0a576861742773207570206c616d6f
#+end_example

**** Sending with nc

Broadcasting:

#+begin_src bash
echo foo bar baz | nc -6 -u ff02::1%enp4s0 16378
#+end_src

Directly to my Windows machine:

#+begin_src bash
nc -6 -u fe80::4a70:73ad:375c:118d%enp4s0 16378
#+end_src

** 2025-06-16 - Reading an SHT20

Horsed around with EnvironmentalSensor2021 a bunch today,
refactoring it to my latest whims and adding support
to send a [[https://www.nuke24.net/docs/2025/HELO.html][#HELO]] packet.

Soldering GX12 connectors is pretty fiddly.
And the wires on [[https://www.aliexpress.us/item/3256804532475698.html][these SHT20s]] are very thin,
and that makes it more fiddly.

I don't entirely trust the wires inside the plug.
How are they not touching the sheath?
Maybe it's not actually metallic,
or there's a layer of insulation.

Or maybe I should cover everything with heat-shrink tubing
and fill it with hot glue to be sure.

** 2025-07-05 - Multiple SHT20s?

Tried sharing D1 = SCL, D2 and D3 = SDA.
This didn't work.  Seemed like the TwoWire library was somehow only 
D1 = SCL, D2 = SDA, D3 = SCL B, D4 = SDA B works even less;
now it can't seem to sense either of them.

But also, something is weird with my code.
When I ~temhum1/read~, the reported ~temhum1/age~ doesn't reset?
I looked at the functions several times to make sure
that both ~updateSht20Reading~ and ~reportReading~ use the passed-in ~&cache~ and not
the global ~sht20ACache~.  What is up with this, hmm...

Maybe I should just get some [[https://learn.adafruit.com/adafruit-tca9548a-1-to-8-i2c-multiplexer-breakout/overview][I2C multiplexerss]] and matching cables.

** 2025-07-05 - MultiSHTDemo

Wrote this while on the bus, so not tested.
Has several different modes to try and see
if any of them work.  Maybe re-initializing the I2C
with different pins will do the job?

** 2025-07-06 - MultiSHTDemo continued

At my desk at home; now I can try it out.
Fixed some bugs.

| Mode                       | Reads  | Reads  |                              |
|                            | SHT20A | SHT20B |                              |
|----------------------------+--------+--------+------------------------------|
| MSD_MODE_TWO_WIRE          | yes    | no     |                              |
| MSD_MODE_FOUR_WIRE_REINIT  | yes    | yes    |                              |
| MSD_MODE_THREE_WIRE_REINIT | yes    | yes    |                              |
| MSD_MODE_THREE_WIRE        | ...    | yes?   | SHT20A returns SHT20B's data |
| MSD_MODE_FOUR_WIRE         | ...    | yes?   | SHT20A returns SHT20B's data |
| MSD_MODE_THREE_WIRE_LOCAL  | yes    | yes    |                              |


*** In summary!

The library must be sharing some global variables, because
having two ~TwoWire~ instances doesn't seem to work.
May as well just use the global ~Wire~ object?

*** TL;DR

Re-initialize a single I2C instance, or put it in a local variable.

The local variable approach might be less suitable if you also
have *other* devices on your bus that have stateful driver objects
associated with the ~TwoWire~ instance.
